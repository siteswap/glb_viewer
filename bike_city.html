<!DOCTYPE html>
<html>
<head>
    <title>GLB First Person Viewer</title>
    <link rel="stylesheet" type="text/css" href="static/css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        .control-btn {
            padding: 45px 90px;
            font-size: 24px;
            border: none;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.2);
            color: white;
            cursor: pointer;
            touch-action: manipulation;
        }
        .stats-container {
            display: flex;
            gap: 20px;
            margin-bottom: 10px;
        }
        #turnLeft {
            position: fixed;
            left: 20px;
            bottom: 20px;
            z-index: 1000;
        }
        #turnRight {
            position: fixed;
            right: 20px;
            bottom: 20px;
            z-index: 1000;
        }
        #fullscreenBtn {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            padding: 15px;
            font-size: 24px;
        }
        .shoot-btn.active {
            background: rgba(255, 0, 0, 0.7);
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="progressContainer">
            <div>Loading Model...</div>
            <div id="progressBar">
                <div id="progressFill"></div>
            </div>
        </div>
        <button class="control-btn" id="turnLeft"><i class="fas fa-arrow-left"></i></button>
        <button class="control-btn" id="turnRight"><i class="fas fa-arrow-right"></i></button>
        <button class="control-btn" id="fullscreenBtn"><i class="fas fa-expand"></i></button>
        <div id="instructions">
            <div class="stats-container">
                <div id="scoreDisplay">0</div>
                <div id="powerDisplay"><span id="powerValue">0</span>W</div>
                <button id="connectButton">Connect</button>
                <button class="shoot-btn" id="shoot"><i class="fas fa-crosshairs"></i></button>
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { MovementController } from './static/js/MovementController.js';
        import { MobiusRingController } from './static/js/MobiusRingController.js';
        import { PlasmaBlastController } from './static/js/PlasmaBlastController.js';

        let scene, camera, renderer, currentModel;
        let movementController, mobiusRingController, plasmaBlastController;
        let score = 0;
        const clock = new THREE.Clock();
        const CYCLING_POWER_SERVICE = 0x1818;
        const CYCLING_POWER_MEASUREMENT = 0x2A63;

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0xf0f0f0);
            document.getElementById('container').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            mobiusRingController = new MobiusRingController(scene); // scene to add/remove
            movementController = new MovementController(camera);
            plasmaBlastController = new PlasmaBlastController(camera, scene);

            // Set up control buttons with continuous rotation
            const turnLeft = document.getElementById('turnLeft');
            const turnRight = document.getElementById('turnRight');
            const shoot = document.getElementById('shoot');
            const fullscreenBtn = document.getElementById('fullscreenBtn');

            // Fullscreen button setup
            fullscreenBtn.addEventListener('click', toggleFullscreen);
            document.addEventListener('fullscreenchange', updateFullscreenButton);

            // Mouse events
            turnLeft.addEventListener('mousedown', () => movementController.setTurnLeft(true));
            turnLeft.addEventListener('mouseup', () => movementController.setTurnLeft(false));
            turnLeft.addEventListener('mouseleave', () => movementController.setTurnLeft(false));

            turnRight.addEventListener('mousedown', () => movementController.setTurnRight(true));
            turnRight.addEventListener('mouseup', () => movementController.setTurnRight(false));
            turnRight.addEventListener('mouseleave', () => movementController.setTurnRight(false));

            // Shoot button now toggles continuous fire
            shoot.addEventListener('click', () => {
                plasmaBlastController.toggleContinuousFire();
                shoot.classList.toggle('active');
            });

            // Touch events
            turnLeft.addEventListener('touchstart', (e) => { 
                e.preventDefault(); // prevent scrolling / text selection
                movementController.setTurnLeft(true);
            });
            turnLeft.addEventListener('touchend', () => movementController.setTurnLeft(false));
            turnLeft.addEventListener('touchcancel', () => movementController.setTurnLeft(false));

            turnRight.addEventListener('touchstart', (e) => { 
                e.preventDefault();
                movementController.setTurnRight(true);
            });
            turnRight.addEventListener('touchend', () => movementController.setTurnRight(false));
            turnRight.addEventListener('touchcancel', () => movementController.setTurnRight(false));

            shoot.addEventListener('touchstart', (e) => {
                e.preventDefault(); // prevent scrolling / text selection
                plasmaBlastController.toggleContinuousFire();
                shoot.classList.toggle('active');
            });

            document.addEventListener('keydown', (e) => movementController.onKeyDown(e));
            document.addEventListener('keyup', (e) => movementController.onKeyUp(e));
            window.addEventListener('resize', onWindowResize, false);

            // Set up trainer connection button
            document.getElementById('connectButton').addEventListener('click', connectToTrainer);

            loadGLB();
            animate();
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.error(`Error attempting to enable fullscreen: ${err.message}`);
                });
            } else {
                document.exitFullscreen();
            }
        }

        function updateFullscreenButton() {
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            const icon = fullscreenBtn.querySelector('i');
            if (document.fullscreenElement) {
                icon.classList.remove('fa-expand');
                icon.classList.add('fa-compress');
            } else {
                icon.classList.remove('fa-compress');
                icon.classList.add('fa-expand');
            }
        }

        function detectCollisions(deltaTime) {
            if (!camera || !scene) return;

            const collidableMeshes = [];
            scene.traverse(object => {
                if (object.isMesh && object !== camera) {
                    collidableMeshes.push(object);
                }
            });

            mobiusRingController.updateMobiusRings(deltaTime);
            movementController.update(deltaTime, collidableMeshes);
            
            const collisions = plasmaBlastController.updatePlasmaBlasts(deltaTime, collidableMeshes);
            
            // Handle collisions
            for (const collision of collisions) {
                const mobiusRing = mobiusRingController.isMobiusRing(collision)
                if (mobiusRing) {
                    if (mobiusRingController.removeRing(mobiusRing)) {
                        score += 1;
                        if (score == 5) { // Fast firing
                            plasmaBlastController.blastColor = 0x0000ff;
                            plasmaBlastController.shootingCooldown = 500;
                        } 
                        if (score == 15) { // The BFG - huge blast radius
                            plasmaBlastController.blastColor = 0xff0000;
                            plasmaBlastController.shootingCooldown = 1000;
                            plasmaBlastController.plasmaLifetime = 3.0;
                            plasmaBlastController.collisionDistance = 5;
                            plasmaBlastController.blastRadius = 4.0;
                        }
                    }
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            
            detectCollisions(deltaTime);
            document.getElementById('scoreDisplay').textContent = `S: ${score}`;

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function loadGLB() {
            const loader = new GLTFLoader();
            const progressContainer = document.getElementById('progressContainer');
            const progressFill = document.getElementById('progressFill');
            
            progressContainer.style.display = 'block';

            if (currentModel) {
                scene.remove(currentModel);
            }

            loader.load(
                'static/glb/town4new.glb',
                function (gltf) {
                    progressContainer.style.display = 'none';
                    
                    currentModel = gltf.scene;
                    scene.add(currentModel);

                    const box = new THREE.Box3().setFromObject(currentModel);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    
                    currentModel.position.x = -center.x;
                    currentModel.position.z = -center.z;
                    
                    // Set camera position to the middle of the scene at height 100
                    camera.position.set(center.x, 100, center.z);

                    // Load mobius rings after city is loaded and positioned
                    mobiusRingController.loadMobiusRings(size);
                },
                function (xhr) {
                    const percent = (xhr.loaded / xhr.total) * 100;
                    progressFill.style.width = percent + '%';
                },
                function (error) {
                    console.error('Error loading GLB:', error);
                    progressContainer.style.display = 'none';
                    alert('Error loading GLB file. Please try again.');
                }
            );
        }

        function parsePower(value) {
            const data = new DataView(value.buffer);
            const flags = data.getUint16(0, true); // First 2 bytes are flags
            const instantaneousPower = data.getInt16(2, true); // Next 2 bytes are instantaneous power in watts (signed)
            return instantaneousPower
        }

        async function connectToTrainer() {
            try {
                const device = await navigator.bluetooth.requestDevice({
                    filters: [{ services: [CYCLING_POWER_SERVICE] }]
                });

                document.getElementById('connectButton').textContent = 'Connecting...';

                const server = await device.gatt.connect();
                const service = await server.getPrimaryService(CYCLING_POWER_SERVICE);
                const characteristic = await service.getCharacteristic(CYCLING_POWER_MEASUREMENT);

                document.getElementById('connectButton').disabled = true;
                document.getElementById('connectButton').textContent = 'Connected';

                // Listen for power measurements
                await characteristic.startNotifications();
                characteristic.addEventListener('characteristicvaluechanged', (event) => {
                    const power = parsePower(event.target.value);
                    document.getElementById('powerValue').textContent = power;
                    movementController.onCyclingPower(power);
                });

            } catch (error) {
                console.error(error);
                document.getElementById('connectButton').textContent = `Error: ${error.message}`;
            }
        }

        init();
    </script>
</body>
</html>
