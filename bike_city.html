<!DOCTYPE html>
<html>
<head>
    <title>GLB First Person Viewer</title>
    <link rel="stylesheet" type="text/css" href="static/css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        .control-btn {
            padding: 12px 12px;
            font-size: 12px;
            border: none;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            cursor: pointer;
            touch-action: manipulation;
        }
        .control-btn:active {
            background: rgba(0, 0, 0, 0.9);
        }
        .stats-container {
            display: flex;
            gap: 20px;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="progressContainer">
            <div>Loading Model...</div>
            <div id="progressBar">
                <div id="progressFill"></div>
            </div>
        </div>
        <div id="instructions">
            <div class="stats-container">
                <div id="scoreDisplay">0</div>
                <div id="powerDisplay"><span id="powerValue">0</span>W</div>
                <button id="connectButton">Connect</button>
            </div>
            <button class="control-btn" id="turnLeft"><i class="fas fa-arrow-left"></i></button>
            <button class="control-btn" id="shoot"><i class="fas fa-crosshairs"></i></button>
            <button class="control-btn" id="turnRight"><i class="fas fa-arrow-right"></i></button>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { PhysicsController } from './static/js/PhysicsController.js';

        let scene, camera, renderer, currentModel;
        let physicsController;
        const clock = new THREE.Clock();
        const ROTATION_ANGLE = Math.PI / 90; // Amount to rotate per frame when held
        const CYCLING_POWER_SERVICE = 0x1818;
        const CYCLING_POWER_MEASUREMENT = 0x2A63;

        // Track button states
        const buttonStates = {
            turnLeft: false,
            turnRight: false,
            shoot: false
        };

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0xf0f0f0);
            document.getElementById('container').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            camera.position.y = 1.8;
            physicsController = new PhysicsController(camera, scene);

            // Set up control buttons with continuous rotation
            const turnLeft = document.getElementById('turnLeft');
            const turnRight = document.getElementById('turnRight');
            const shoot = document.getElementById('shoot');

            // Mouse events
            turnLeft.addEventListener('mousedown', () => { buttonStates.turnLeft = true; });
            turnLeft.addEventListener('mouseup', () => { buttonStates.turnLeft = false; });
            turnLeft.addEventListener('mouseleave', () => { buttonStates.turnLeft = false; });

            turnRight.addEventListener('mousedown', () => { buttonStates.turnRight = true; });
            turnRight.addEventListener('mouseup', () => { buttonStates.turnRight = false; });
            turnRight.addEventListener('mouseleave', () => { buttonStates.turnRight = false; });

            shoot.addEventListener('mousedown', () => { buttonStates.shoot = true; });
            shoot.addEventListener('mouseup', () => { buttonStates.shoot = false; });
            shoot.addEventListener('mouseleave', () => { buttonStates.shoot = false; });

            // Touch events
            turnLeft.addEventListener('touchstart', (e) => { 
                e.preventDefault();
                buttonStates.turnLeft = true; 
            });
            turnLeft.addEventListener('touchend', () => { buttonStates.turnLeft = false; });
            turnLeft.addEventListener('touchcancel', () => { buttonStates.turnLeft = false; });

            turnRight.addEventListener('touchstart', (e) => { 
                e.preventDefault();
                buttonStates.turnRight = true; 
            });
            turnRight.addEventListener('touchend', () => { buttonStates.turnRight = false; });
            turnRight.addEventListener('touchcancel', () => { buttonStates.turnRight = false; });

            shoot.addEventListener('touchstart', (e) => {
                e.preventDefault();
                buttonStates.shoot = true;
            });
            shoot.addEventListener('touchend', () => { buttonStates.shoot = false; });
            shoot.addEventListener('touchcancel', () => { buttonStates.shoot = false; });

            document.addEventListener('keydown', (e) => physicsController.onKeyDown(e));
            document.addEventListener('keyup', (e) => physicsController.onKeyUp(e));
            window.addEventListener('resize', onWindowResize, false);

            // Set up trainer connection button
            document.getElementById('connectButton').addEventListener('click', connectToTrainer);

            loadGLB();
            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            
            // Apply continuous rotation if buttons are held
            if (buttonStates.turnLeft) {
                camera.rotation.y += ROTATION_ANGLE;
            }
            if (buttonStates.turnRight) {
                camera.rotation.y -= ROTATION_ANGLE;
            }
            
            // Handle continuous shooting
            if (buttonStates.shoot) {
                physicsController.onShootButtonHeld();
            }
            
            physicsController.update(deltaTime);
            document.getElementById('scoreDisplay').textContent = `S: ${physicsController.score}`;

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function loadGLB() {
            const loader = new GLTFLoader();
            const progressContainer = document.getElementById('progressContainer');
            const progressFill = document.getElementById('progressFill');
            
            progressContainer.style.display = 'block';

            if (currentModel) {
                scene.remove(currentModel);
            }

            loader.load(
                'static/glb/town4new.glb',
                function (gltf) {
                    progressContainer.style.display = 'none';
                    
                    currentModel = gltf.scene;
                    scene.add(currentModel);

                    const box = new THREE.Box3().setFromObject(currentModel);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    
                    currentModel.position.x = -center.x;
                    currentModel.position.z = -center.z;
                    
                    camera.position.set(size.x / 2, 1.8, size.z / 2);

                    // Load mobius rings after city is loaded and positioned
                    physicsController.loadMobiusRings(size);
                },
                function (xhr) {
                    const percent = (xhr.loaded / xhr.total) * 100;
                    progressFill.style.width = percent + '%';
                },
                function (error) {
                    console.error('Error loading GLB:', error);
                    progressContainer.style.display = 'none';
                    alert('Error loading GLB file. Please try again.');
                }
            );
        }

        function parsePower(value) {
            const data = new DataView(value.buffer);
            // Power is typically in the first 2 bytes (little endian)
            return data.getUint16(0, true);
        }

        async function connectToTrainer() {
            try {
                const device = await navigator.bluetooth.requestDevice({
                    filters: [{ services: [CYCLING_POWER_SERVICE] }]
                });

                document.getElementById('connectButton').textContent = 'Connecting...';

                const server = await device.gatt.connect();
                const service = await server.getPrimaryService(CYCLING_POWER_SERVICE);
                const characteristic = await service.getCharacteristic(CYCLING_POWER_MEASUREMENT);

                document.getElementById('connectButton').disabled = true;
                document.getElementById('connectButton').textContent = 'Connected';

                // Listen for power measurements
                await characteristic.startNotifications();
                characteristic.addEventListener('characteristicvaluechanged', (event) => {
                    const power = parsePower(event.target.value);
                    document.getElementById('powerValue').textContent = power;
                    physicsController.onCyclingPower(power);
                });

            } catch (error) {
                console.error(error);
                document.getElementById('connectButton').textContent = `Error: ${error.message}`;
            }
        }

        init();
    </script>
</body>
</html>
